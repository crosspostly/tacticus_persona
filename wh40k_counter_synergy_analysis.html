<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WH40K Tacticus - –ê–Ω–∞–ª–∏–∑ –ö–æ–Ω—Ç—Ä–æ–≤ –∏ –°–∏–Ω–µ—Ä–≥–∏–∏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .character-selector {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            margin-bottom: 30px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #ffeb3b;
        }
        
        select {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #ffd700;
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
        }
        
        select option {
            background: #1e3c72;
            color: #fff;
        }
        
        .analysis-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .analysis-section {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
        }
        
        .counters-section {
            border-color: #ff6b6b;
        }
        
        .synergies-section {
            border-color: #00ff00;
        }
        
        .analysis-section h2 {
            margin-bottom: 15px;
            color: #ffd700;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 10px;
        }
        
        .counters-section h2 {
            color: #ff6b6b;
            border-bottom-color: #ff6b6b;
        }
        
        .synergies-section h2 {
            color: #00ff00;
            border-bottom-color: #00ff00;
        }
        
        .character-info {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .info-label {
            font-weight: bold;
            color: #ffeb3b;
        }
        
        .traits-display {
            margin-top: 10px;
        }
        
        .trait-tag {
            display: inline-block;
            background: #ffd700;
            color: #000;
            padding: 2px 8px;
            border-radius: 3px;
            margin: 2px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .analysis-item {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            border-left: 4px solid;
        }
        
        .counter-item {
            border-left-color: #ff6b6b;
        }
        
        .synergy-item {
            border-left-color: #00ff00;
        }
        
        .item-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .counter-item .item-name {
            color: #ff6b6b;
        }
        
        .synergy-item .item-name {
            color: #00ff00;
        }
        
        .item-reason {
            margin-bottom: 8px;
            color: #ccc;
        }
        
        .item-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
        }
        
        .difficulty {
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        .difficulty-extreme { background: #8b0000; }
        .difficulty-very-hard { background: #ff0000; }
        .difficulty-hard { background: #ff6b6b; }
        .difficulty-medium { background: #ffa500; }
        .difficulty-easy { background: #ffff00; }
        
        .rating {
            color: #ffd700;
        }
        
        .score {
            color: #ccc;
        }
        
        .sources {
            margin-top: 8px;
            font-size: 0.8em;
            color: #888;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #ffd700;
        }
        
        .error {
            background: rgba(255,0,0,0.2);
            border: 2px solid #ff6b6b;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .buttons {
            text-align: center;
            margin: 20px 0;
        }
        
        .btn {
            background: #ffd700;
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: #ffed4e;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ WH40K TACTICUS - –ê–ù–ê–õ–ò–ó –ö–û–ù–¢–†–û–í –ò –°–ò–ù–ï–†–ì–ò–ò</h1>
        
        <div class="character-selector">
            <div class="form-group">
                <label for="characterSelect">–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:</label>
                <select id="characterSelect">
                    <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ --</option>
                </select>
            </div>
            
            <div class="buttons">
                <button class="btn" onclick="analyzeCharacter()" id="analyzeBtn" disabled>üîç –ê–ù–ê–õ–ò–ó–ò–†–û–í–ê–¢–¨</button>
                <button class="btn" onclick="generateAllAnalysis()">üìä –ê–ù–ê–õ–ò–ó –í–°–ï–•</button>
                <button class="btn" onclick="exportResults()">üíæ –≠–ö–°–ü–û–†–¢</button>
            </div>
        </div>
        
        <div id="characterInfo" class="character-info" style="display: none;">
            <h3>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ</h3>
            <div id="characterDetails"></div>
        </div>
        
        <div class="analysis-container" id="analysisContainer" style="display: none;">
            <div class="analysis-section counters-section">
                <h2>‚ö†Ô∏è –ö–û–ù–¢–†–´</h2>
                <div id="countersList"></div>
            </div>
            
            <div class="analysis-section synergies-section">
                <h2>ü§ù –°–ò–ù–ï–†–ì–ò–Ø</h2>
                <div id="synergiesList"></div>
            </div>
        </div>
        
        <div id="loading" class="loading" style="display: none;">
            –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let allCharacters = [];
        let currentAnalysis = null;
        
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        const RARITY_MULTIPLIERS = {
            "Common": 1,
            "Uncommon": 2,
            "Rare": 3,
            "Epic": 5,
            "Legendary": 10,
            "Mythic": 15
        };
        
        const TRAIT_HARD_COUNTERS = {
            "Flying": ["Overwatch", "Suppressive Fire", "Anti-Air"],
            "Summon": ["AOE", "Swarm_Clear", "Area_Denial"],
            "Psyker": ["Psychic_Fortress", "Mental_Block"],
            "Terminator Armour": ["Psychic", "Direct", "Molecular"],
            "Resilient": ["Burst_Damage", "Overkill_Potential"],
            "Deep Strike": ["Overwatch", "Infiltrate_Detection"],
            "Final Vengeance": ["Healing", "Shield", "Resurrection"],
            "Terrifying": ["Fearless", "Immune_To_Fear"],
            "Living Metal": ["Corrosion", "EMP", "Energy_Weapons"],
            "Parry": ["Unblockable", "Chain_Hits"]
        };
        
        const TRAIT_SOFT_COUNTERS = {
            "Rapid Assault": ["Parry", "Block_Chance"],
            "Heavy Weapon": ["Evasion", "Dodge"],
            "Overwatch": ["Infiltrate", "Flying_Escape"],
            "Suppressive Fire": ["Immunity", "Counter_Attack"]
        };
        
        const SYNERGISTIC_TRAIT_PAIRS = {
            "Flying": ["Deep Strike", "Infiltrate", "Evasion"],
            "Final Vengeance": ["Rapid Assault", "Multi-Hit"],
            "Psyker": ["Psyker"],
            "Summon": ["Rapid Assault", "Swarm"],
            "Heavy Weapon": ["Spotter", "High Ground"],
            "Overwatch": ["Suppressive Fire", "First Strike"],
            "Resilient": ["Terminator Armour", "Living Metal"],
            "Terrifying": ["Fearless", "Leadership"]
        };
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ data.json
        async function loadData() {
            try {
                document.getElementById('loading').style.display = 'block';
                const response = await fetch('data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                allCharacters = await response.json();
                populateCharacterSelect();
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                showError('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
        function populateCharacterSelect() {
            const select = document.getElementById('characterSelect');
            select.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ --</option>';
            
            allCharacters.forEach(char => {
                const option = document.createElement('option');
                option.value = char.name;
                option.textContent = `${char.name} (${char.rarity})`;
                select.appendChild(option);
            });
            
            select.addEventListener('change', function() {
                document.getElementById('analyzeBtn').disabled = !this.value;
            });
        }
        
        // –ü–∞—Ä—Å–∏–Ω–≥ –∞—Ç–∞–∫ –∏–∑ —Å—Ç—Ä–æ–∫–∏
        function parseAttack(attackString) {
            if (!attackString) return { hits: 1, pierce: 0, type: 'Power' };
            
            const parts = attackString.split('/');
            let hits = 1;
            let pierce = 0;
            let type = 'Power';
            
            // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ hits
            const hitsMatch = attackString.match(/(\d+)\s*hits?/i);
            if (hitsMatch) hits = parseInt(hitsMatch[1]);
            
            // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ pierce
            if (attackString.toLowerCase().includes('piercing')) {
                pierce = 80; // —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π piercing
            } else if (attackString.toLowerCase().includes('psychic')) {
                pierce = 100; // psychic –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –±—Ä–æ–Ω—é
            } else {
                pierce = 40; // —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π power
            }
            
            // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–∏–ø–∞
            if (attackString.toLowerCase().includes('piercing')) type = 'Piercing';
            else if (attackString.toLowerCase().includes('psychic')) type = 'Psychic';
            else if (attackString.toLowerCase().includes('flame')) type = 'Flame';
            else if (attackString.toLowerCase().includes('poison')) type = 'Poison';
            else type = 'Power';
            
            return { hits, pierce, type };
        }
        
        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        function normalizeCharacter(char) {
            return {
                name: char.name,
                baseStats: {
                    health: parseInt(char.baseStats?.health || 100),
                    armour: parseInt(char.baseStats?.armour || 20),
                    damage: parseInt(char.baseStats?.damage || 10)
                },
                rarity: char.rarity || 'Common',
                traits: char.traits ? char.traits.split(',').map(t => t.trim()) : [],
                attacks: {
                    melee: parseAttack(char.attacks?.melee || ''),
                    ranged: parseAttack(char.attacks?.ranged || '')
                },
                passiveAbility: char.passiveAbility || null,
                activeAbility: char.activeAbility || null,
                faction: char.faction || 'Unknown'
            };
        }
        
        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–æ–ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        function detectRole(character) {
            let role = [];
            let { health, armour, damage } = character.baseStats;
            let multiplier = RARITY_MULTIPLIERS[character.rarity] || 1;
            
            let effectiveHp = health * Math.sqrt(multiplier);
            let effectiveDmg = damage * multiplier;
            let effectiveArm = armour * Math.sqrt(multiplier);
            
            if (effectiveDmg > 300 && effectiveArm < 30) role.push("DPS");
            if (effectiveHp > 200 && effectiveArm > 25) role.push("TANK");
            if (character.passiveAbility?.description?.toLowerCase().includes("heal")) role.push("HEALER");
            if (character.passiveAbility?.description?.toLowerCase().includes("friendly") || 
                character.passiveAbility?.description?.toLowerCase().includes("aura")) role.push("BUFFER");
            if (character.traits.includes("Summon")) role.push("SUMMONER");
            
            return role.length > 0 ? role : ["GENERAL"];
        }
        
        // –ü–æ–∏—Å–∫ –∫–æ–Ω—Ç—Ä–æ–≤ –ø–æ pierce
        function findPierceCounters(attacker) {
            let counters = [];
            let attackerNorm = normalizeCharacter(attacker);
            
            // LOW pierce –∫–æ–Ω—Ç—Ä—ã
            if (attackerNorm.attacks.melee.pierce <= 20 || 
                attackerNorm.attacks.ranged.pierce <= 20) {
                
                allCharacters.forEach(defender => {
                    if (defender.name !== attacker.name) {
                        let defenderNorm = normalizeCharacter(defender);
                        
                        if (defenderNorm.baseStats.armour >= 30) {
                            if (defenderNorm.traits.includes("Terminator Armour")) {
                                counters.push({
                                    name: defender.name,
                                    reason: "Low Pierce + High Armor + Terminator Armour = –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ",
                                    difficulty: "VERY_HARD",
                                    score: 0.15,
                                    explanation: `Low Pierce (${attackerNorm.attacks.melee.pierce}%) –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–æ—Ç–∏–≤ Terminator Armour!`,
                                    sources: ["Pierce Counter"]
                                });
                            }
                        }
                    }
                });
            }
            
            // HIGH pierce –∫–æ–Ω—Ç—Ä—ã
            if (attackerNorm.attacks.melee.pierce >= 80 || 
                attackerNorm.attacks.ranged.pierce >= 80) {
                
                allCharacters.forEach(defender => {
                    if (defender.name !== attacker.name) {
                        let defenderNorm = normalizeCharacter(defender);
                        
                        if (defenderNorm.traits.includes("Resilient")) {
                            counters.push({
                                name: defender.name,
                                reason: "High Pierce –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –±—Ä–æ–Ω—é, –Ω–æ Resilient —É–º–µ–Ω—å—à–∞–µ—Ç —É—Ä–æ–Ω",
                                difficulty: "MEDIUM",
                                score: 0.80,
                                explanation: `Psyker/High Pierce –ø—Ä–æ—Ö–æ–¥–∏—Ç, –Ω–æ Resilient -20% —É—Ä–æ–Ω–∞!`,
                                sources: ["Pierce Counter"]
                            });
                        }
                    }
                });
            }
            
            return counters;
        }
        
        // –ü–æ–∏—Å–∫ –∫–æ–Ω—Ç—Ä–æ–≤ –ø–æ traits
        function findTraitCounters(attacker) {
            let counters = [];
            let attackerNorm = normalizeCharacter(attacker);
            
            // HARD COUNTERS
            attackerNorm.traits.forEach(trait => {
                if (TRAIT_HARD_COUNTERS[trait]) {
                    TRAIT_HARD_COUNTERS[trait].forEach(counterTrait => {
                        allCharacters.forEach(defender => {
                            if (defender.name !== attacker.name) {
                                let defenderNorm = normalizeCharacter(defender);
                                
                                if (defenderNorm.traits.some(t => t.includes(counterTrait))) {
                                    counters.push({
                                        name: defender.name,
                                        reason: `${counterTrait} –ø—Ä—è–º–æ –∫–æ–Ω—Ç—Ä–∏—Ç ${trait}`,
                                        difficulty: "HARD",
                                        score: 0.30,
                                        traits: { attacking: trait, defending: counterTrait },
                                        sources: ["Trait Counter"]
                                    });
                                }
                            }
                        });
                    });
                }
            });
            
            // SOFT COUNTERS
            attackerNorm.traits.forEach(trait => {
                if (TRAIT_SOFT_COUNTERS[trait]) {
                    TRAIT_SOFT_COUNTERS[trait].forEach(counterTrait => {
                        allCharacters.forEach(defender => {
                            if (defender.name !== attacker.name) {
                                let defenderNorm = normalizeCharacter(defender);
                                
                                if (defenderNorm.traits.some(t => t.includes(counterTrait))) {
                                    counters.push({
                                        name: defender.name,
                                        reason: `${counterTrait} —É–º–µ–Ω—å—à–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç ${trait}`,
                                        difficulty: "MEDIUM",
                                        score: 0.60,
                                        traits: { attacking: trait, defending: counterTrait },
                                        sources: ["Trait Counter"]
                                    });
                                }
                            }
                        });
                    });
                }
            });
            
            return counters;
        }
        
        // –ü–æ–∏—Å–∫ –∫–æ–Ω—Ç—Ä–æ–≤ –ø–æ —Ä–æ–ª—è–º
        function findRoleCounters(attacker) {
            let counters = [];
            let attackerNorm = normalizeCharacter(attacker);
            let attackerRole = detectRole(attackerNorm);
            
            const ROLE_COUNTERS = {
                "DPS": ["TANK", "BUFFER"],
                "TANK": ["HIGH_PIERCE", "MOBILITY"],
                "HEALER": ["BURST_DPS", "ISOLATED_BURST"],
                "BUFFER": ["SILENCER", "ISOLATED_TARGET"],
                "SUMMONER": ["AOE", "SUPPRESSION"]
            };
            
            attackerRole.forEach(role => {
                if (ROLE_COUNTERS[role]) {
                    let counterTypes = ROLE_COUNTERS[role];
                    
                    allCharacters.forEach(defender => {
                        if (defender.name !== attacker.name) {
                            let defenderNorm = normalizeCharacter(defender);
                            let defenderRole = detectRole(defenderNorm);
                            
                            if (counterTypes.some(ct => defenderRole.includes(ct.replace("HIGH_PIERCE", "").replace("MOBILITY", "")))) {
                                counters.push({
                                    name: defender.name,
                                    reason: `${defenderRole.join("/")} –∫–æ–Ω—Ç—Ä–∏—Ç ${role}`,
                                    difficulty: "HARD",
                                    score: 0.40,
                                    roles: { attacking: role, defending: defenderRole },
                                    sources: ["Role Counter"]
                                });
                            }
                        }
                    });
                }
            });
            
            return counters;
        }
        
        // –°–∏–º—É–ª—è—Ü–∏—è –º–∞—Ç—á–µ–π
        function simulateMatchup(attacker, defender) {
            let attackerNorm = normalizeCharacter(attacker);
            let defenderNorm = normalizeCharacter(defender);
            
            // –†–∞—Å—á–µ—Ç —É—Ä–æ–Ω–∞
            let attackerDamage = calculateDamage(attackerNorm, defenderNorm);
            let defenderDamage = calculateDamage(defenderNorm, attackerNorm);
            
            // Turns to kill
            let attackerMult = RARITY_MULTIPLIERS[attackerNorm.rarity] || 1;
            let defenderMult = RARITY_MULTIPLIERS[defenderNorm.rarity] || 1;
            
            let ttkAttacker = Math.ceil(
                (defenderNorm.baseStats.health * defenderMult) / 
                Math.max(1, attackerDamage)
            );
            
            let ttkDefender = Math.ceil(
                (attackerNorm.baseStats.health * attackerMult) / 
                Math.max(1, defenderDamage)
            );
            
            // Win probability
            let winProbability;
            if (ttkAttacker < ttkDefender) {
                winProbability = 0.8 + Math.random() * 0.2;
            } else if (ttkAttacker === ttkDefender) {
                winProbability = 0.5;
            } else {
                winProbability = 0.2 - Math.random() * 0.2;
            }
            
            return {
                attackerDamage,
                defenderDamage,
                ttkAttacker,
                ttkDefender,
                winProbability,
                isCounter: winProbability < 0.35
            };
        }
        
        // –†–∞—Å—á–µ—Ç —É—Ä–æ–Ω–∞
        function calculateDamage(attacker, defender) {
            let damage = attacker.baseStats.damage;
            let mult = RARITY_MULTIPLIERS[attacker.rarity] || 1;
            let damVar = damage * mult;
            
            let variant1 = damVar - defender.baseStats.armour;
            let variant2 = damVar * (attacker.attacks.melee.pierce / 100);
            let damageAfterArmor = Math.max(variant1, variant2, 0);
            
            return damageAfterArmor * attacker.attacks.melee.hits;
        }
        
        // –ü–æ–∏—Å–∫ –∫–æ–Ω—Ç—Ä–æ–≤ —á–µ—Ä–µ–∑ —Å–∏–º—É–ª—è—Ü–∏—é
        function simulateMatchups(attacker) {
            let counters = [];
            
            allCharacters.forEach(defender => {
                if (defender.name !== attacker.name) {
                    let sim = simulateMatchup(attacker, defender);
                    
                    if (sim.isCounter) {
                        counters.push({
                            name: defender.name,
                            reason: `–°–∏–º—É–ª—è—Ü–∏—è: ${sim.ttkAttacker} —Ö–æ–¥–æ–≤ –¥–ª—è —É–±–∏–π—Å—Ç–≤–∞ vs ${sim.ttkDefender} —Ö–æ–¥–æ–≤ –¥–ª—è —Å–º–µ—Ä—Ç–∏`,
                            difficulty: sim.winProbability < 0.1 ? "VERY_HARD" : "HARD",
                            score: sim.winProbability,
                            simulation: sim,
                            sources: ["Simulation"]
                        });
                    }
                }
            });
            
            return counters;
        }
        
        // –†–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–≤
        function rankCounters(countersList) {
            let uniqueCounters = {};
            countersList.forEach(counter => {
                if (!uniqueCounters[counter.name]) {
                    uniqueCounters[counter.name] = { ...counter, matches: 1 };
                } else {
                    uniqueCounters[counter.name].matches++;
                    uniqueCounters[counter.name].score = 
                        (uniqueCounters[counter.name].score + counter.score) / 2;
                    uniqueCounters[counter.name].sources = [
                        ...new Set([...uniqueCounters[counter.name].sources, ...counter.sources])
                    ];
                }
            });
            
            let ranked = Object.values(uniqueCounters)
                .sort((a, b) => a.score - b.score)
                .slice(0, 5);
            
            ranked.forEach(counter => {
                if (counter.score < 0.2) counter.difficulty = "EXTREME";
                else if (counter.score < 0.35) counter.difficulty = "VERY_HARD";
                else if (counter.score < 0.5) counter.difficulty = "HARD";
                else if (counter.score < 0.65) counter.difficulty = "MEDIUM";
            });
            
            return ranked;
        }
        
        // –ü–æ–∏—Å–∫ —Å–∏–Ω–µ—Ä–≥–∏–π –ø–æ —Ñ—Ä–∞–∫—Ü–∏–∏
        function findFactionSynergies(character) {
            let synergies = [];
            let charNorm = normalizeCharacter(character);
            
            if (!charNorm.faction || charNorm.faction === "N/A" || charNorm.faction === "Unknown") {
                return synergies;
            }
            
            allCharacters.forEach(partner => {
                if (partner.name !== character.name) {
                    let partnerNorm = normalizeCharacter(partner);
                    
                    if (partnerNorm.faction === charNorm.faction) {
                        let factionBonus = 0;
                        if (charNorm.passiveAbility?.description?.toLowerCase().includes("friendly")) {
                            factionBonus = 0.20;
                        }
                        
                        synergies.push({
                            name: partner.name,
                            reason: `–û–¥–Ω–∞ —Ñ—Ä–∞–∫—Ü–∏—è: ${charNorm.faction}`,
                            type: "FACTION",
                            bonus: factionBonus,
                            score: 0.5 + factionBonus,
                            rating: Math.ceil((0.5 + factionBonus) * 5),
                            sources: ["Faction Synergy"]
                        });
                    }
                }
            });
            
            return synergies;
        }
        
        // –ü–æ–∏—Å–∫ —Å–∏–Ω–µ—Ä–≥–∏–π –ø–æ traits
        function findTraitSynergies(character) {
            let synergies = [];
            let charNorm = normalizeCharacter(character);
            
            charNorm.traits.forEach(trait => {
                if (SYNERGISTIC_TRAIT_PAIRS[trait]) {
                    let synergisticTraits = SYNERGISTIC_TRAIT_PAIRS[trait];
                    
                    allCharacters.forEach(partner => {
                        if (partner.name !== character.name) {
                            let partnerNorm = normalizeCharacter(partner);
                            let matching = partnerNorm.traits.filter(t => 
                                synergisticTraits.some(st => t.includes(st))
                            );
                            
                            if (matching.length > 0) {
                                synergies.push({
                                    name: partner.name,
                                    reason: `${trait} —Å–∏–Ω–µ—Ä–≥–∏–∑–∏—Ä—É–µ—Ç —Å ${matching.join(", ")}`,
                                    type: "TRAIT",
                                    bonus: matching.length * 0.15,
                                    score: 0.6 + (matching.length * 0.15),
                                    rating: Math.ceil((0.6 + matching.length * 0.15) * 5),
                                    traits: { myTrait: trait, partnerTraits: matching },
                                    sources: ["Trait Synergy"]
                                });
                            }
                        }
                    });
                }
            });
            
            return synergies;
        }
        
        // –ü–æ–∏—Å–∫ —Å–∏–Ω–µ—Ä–≥–∏–π –ø–æ —Ä–æ–ª—è–º
        function findRoleSynergies(character) {
            let synergies = [];
            let charNorm = normalizeCharacter(character);
            let charRole = detectRole(charNorm);
            
            const GOOD_TEAM_COMPOSITIONS = [
                { name: "Tank + Support + DPS", roles: ["TANK", "HEALER", "DPS"], synergy: 0.8 },
                { name: "Buffer + Damage Dealers", roles: ["BUFFER", "DPS", "DPS"], synergy: 0.75 },
                { name: "Summon + AOE + Control", roles: ["SUMMONER", "DPS", "TANK"], synergy: 0.70 }
            ];
            
            GOOD_TEAM_COMPOSITIONS.forEach(comp => {
                comp.roles.forEach(neededRole => {
                    allCharacters.forEach(partner => {
                        if (partner.name !== character.name) {
                            let partnerNorm = normalizeCharacter(partner);
                            let partnerRole = detectRole(partnerNorm);
                            
                            if (partnerRole.includes(neededRole)) {
                                synergies.push({
                                    name: partner.name,
                                    reason: `${neededRole} –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ ${comp.name}`,
                                    type: "ROLE",
                                    composition: comp.name,
                                    bonus: comp.synergy * 0.1,
                                    score: 0.4 + comp.synergy * 0.1,
                                    rating: Math.ceil(comp.synergy * 5),
                                    sources: ["Role Synergy"]
                                });
                            }
                        }
                    });
                });
            });
            
            return synergies;
        }
        
        // –ü–æ–∏—Å–∫ —Å–∏–Ω–µ—Ä–≥–∏–π –ø–æ —Ç–∏–ø–∞–º —É—Ä–æ–Ω–∞
        function findDamageTypeSynergies(character) {
            let synergies = [];
            let charNorm = normalizeCharacter(character);
            let myDamageType = charNorm.attacks.melee.type;
            
            const DAMAGE_TYPE_SYNERGIES = {
                "Psychic": { "Psychic": 0.20, "Direct": 0.15, "Piercing": 0.10 },
                "Piercing": { "Psychic": 0.10, "Piercing": 0.15, "Power": 0.05 },
                "Power": { "Power": 0.10, "Flame": 0.10, "Poison": 0.10 }
            };
            
            if (DAMAGE_TYPE_SYNERGIES[myDamageType]) {
                allCharacters.forEach(partner => {
                    if (partner.name !== character.name) {
                        let partnerNorm = normalizeCharacter(partner);
                        let partnerDamageType = partnerNorm.attacks.melee.type;
                        
                        if (DAMAGE_TYPE_SYNERGIES[myDamageType][partnerDamageType]) {
                            let bonus = DAMAGE_TYPE_SYNERGIES[myDamageType][partnerDamageType];
                            
                            synergies.push({
                                name: partner.name,
                                reason: `${myDamageType} + ${partnerDamageType} —Å–∏–Ω–µ—Ä–≥–∏—è —É—Ä–æ–Ω–∞`,
                                type: "DAMAGE_TYPE",
                                bonus: bonus,
                                score: 0.5 + bonus,
                                rating: Math.ceil((0.5 + bonus) * 5),
                                damageTypes: { mine: myDamageType, theirs: partnerDamageType },
                                sources: ["Damage Type Synergy"]
                            });
                        }
                    }
                });
            }
            
            return synergies;
        }
        
        // –†–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏–Ω–µ—Ä–≥–∏–π
        function rankSynergies(synergiesList) {
            let uniqueSynergies = {};
            synergiesList.forEach(syn => {
                if (!uniqueSynergies[syn.name]) {
                    uniqueSynergies[syn.name] = { ...syn, matches: 1 };
                } else {
                    uniqueSynergies[syn.name].matches++;
                    uniqueSynergies[syn.name].score = 
                        (uniqueSynergies[syn.name].score + syn.score) / 2;
                    uniqueSynergies[syn.name].sources = [
                        ...new Set([...uniqueSynergies[syn.name].sources, ...syn.sources])
                    ];
                }
            });
            
            let ranked = Object.values(uniqueSynergies)
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            ranked.forEach(syn => {
                syn.stars = Math.min(5, Math.ceil(syn.score * 5));
            });
            
            return ranked;
        }
        
        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞
        function analyzeCharacterData(characterName) {
            let character = allCharacters.find(c => c.name === characterName);
            if (!character) return null;
            
            let counters = rankCounters([
                ...findPierceCounters(character),
                ...findTraitCounters(character),
                ...findRoleCounters(character),
                ...simulateMatchups(character)
            ]);
            
            let synergies = rankSynergies([
                ...findFactionSynergies(character),
                ...findTraitSynergies(character),
                ...findRoleSynergies(character),
                ...findDamageTypeSynergies(character)
            ]);
            
            return {
                name: character.name,
                character: normalizeCharacter(character),
                counters: counters,
                synergies: synergies
            };
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ
        function displayCharacterInfo(character) {
            const infoDiv = document.getElementById('characterInfo');
            const detailsDiv = document.getElementById('characterDetails');
            
            let charNorm = normalizeCharacter(character);
            let role = detectRole(charNorm);
            
            detailsDiv.innerHTML = `
                <div class="info-row">
                    <span class="info-label">–ò–º—è:</span>
                    <span>${character.name}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">–§—Ä–∞–∫—Ü–∏—è:</span>
                    <span>${character.faction}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">–†–µ–¥–∫–æ—Å—Ç—å:</span>
                    <span>${character.rarity}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">–†–æ–ª—å:</span>
                    <span>${role.join(", ")}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">–•–ü:</span>
                    <span>${charNorm.baseStats.health}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">–ë—Ä–æ–Ω—è:</span>
                    <span>${charNorm.baseStats.armour}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">–£—Ä–æ–Ω:</span>
                    <span>${charNorm.baseStats.damage}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">–ê—Ç–∞–∫–∞:</span>
                    <span>${charNorm.attacks.melee.type} ${charNorm.attacks.melee.hits}—Ö ${charNorm.attacks.melee.pierce}% pierce</span>
                </div>
                <div class="traits-display">
                    <strong>–¢—Ä–µ–π—Ç—ã:</strong><br>
                    ${charNorm.traits.map(t => `<span class="trait-tag">${t}</span>`).join('')}
                </div>
            `;
            
            infoDiv.style.display = 'block';
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–≤
        function displayCounters(counters) {
            const countersDiv = document.getElementById('countersList');
            
            if (counters.length === 0) {
                countersDiv.innerHTML = '<p>–ö–æ–Ω—Ç—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</p>';
                return;
            }
            
            countersDiv.innerHTML = counters.map(counter => `
                <div class="analysis-item counter-item">
                    <div class="item-name">${counter.name}</div>
                    <div class="item-reason">${counter.reason}</div>
                    ${counter.explanation ? `<div class="item-reason"><em>${counter.explanation}</em></div>` : ''}
                    <div class="item-details">
                        <span class="difficulty difficulty-${counter.difficulty.toLowerCase().replace('_', '-')}">${counter.difficulty}</span>
                        <span class="score">–°—á–µ—Ç: ${(counter.score * 100).toFixed(1)}%</span>
                    </div>
                    <div class="sources">–ò—Å—Ç–æ—á–Ω–∏–∫–∏: ${counter.sources.join(', ')}</div>
                </div>
            `).join('');
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–∏–Ω–µ—Ä–≥–∏–π
        function displaySynergies(synergies) {
            const synergiesDiv = document.getElementById('synergiesList');
            
            if (synergies.length === 0) {
                synergiesDiv.innerHTML = '<p>–°–∏–Ω–µ—Ä–≥–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</p>';
                return;
            }
            
            synergiesDiv.innerHTML = synergies.map(synergy => `
                <div class="analysis-item synergy-item">
                    <div class="item-name">${synergy.name}</div>
                    <div class="item-reason">${synergy.reason}</div>
                    <div class="item-details">
                        <span class="rating">‚òÖ${synergy.stars || synergy.rating}</span>
                        <span class="score">–ë–æ–Ω—É—Å: +${(synergy.bonus * 100).toFixed(1)}%</span>
                    </div>
                    <div class="sources">–ò—Å—Ç–æ—á–Ω–∏–∫–∏: ${synergy.sources.join(', ')}</div>
                </div>
            `).join('');
        }
        
        // –ê–Ω–∞–ª–∏–∑ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        function analyzeCharacter() {
            const characterName = document.getElementById('characterSelect').value;
            if (!characterName) return;
            
            const character = allCharacters.find(c => c.name === characterName);
            if (!character) {
                showError('–ü–µ—Ä—Å–æ–Ω–∞–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }
            
            displayCharacterInfo(character);
            
            const analysis = analyzeCharacterData(characterName);
            if (analysis) {
                currentAnalysis = analysis;
                displayCounters(analysis.counters);
                displaySynergies(analysis.synergies);
                document.getElementById('analysisContainer').style.display = 'grid';
            }
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è –≤—Å–µ—Ö –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
        async function generateAllAnalysis() {
            const results = {};
            
            for (let character of allCharacters) {
                try {
                    const analysis = analyzeCharacterData(character.name);
                    if (analysis) {
                        results[character.name] = analysis;
                    }
                } catch (error) {
                    console.error(`Error analyzing ${character.name}:`, error);
                }
            }
            
            currentAnalysis = results;
            alert(`–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω –¥–ª—è ${Object.keys(results).length} –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π!`);
        }
        
        // –≠–∫—Å–ø–æ—Ä—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        function exportResults() {
            if (!currentAnalysis) {
                showError('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞');
                return;
            }
            
            const dataStr = JSON.stringify(currentAnalysis, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = 'wh40k_analysis_results.json';
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }
        
        // –ü–æ–∫–∞–∑ –æ—à–∏–±–∫–∏
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        window.onload = function() {
            loadData();
        };
    </script>
</body>
</html>